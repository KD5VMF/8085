---------------------------------------------
OSHONSOFT 8085 ASSEMBLER LISTING
Line   Addr Opcode      Label   Instruction
---------------------------------------------
0001   0000             ; Compiled with: 8085 Simulator IDE v6.67
0002   0000             ; Microprocessor model: 8085
0003   0000             ; Clock frequency: 4.0MHz
0004   0000             ;
0005   0000             ;       The address of 'read' (ushort) (global) is 0xFEF6 (-10)
0006   0000             ;       The address of 'write' (ushort) (global) is 0xFEF9 (-7)
0007   0000             ;       The address of 'startclkupdate' (ushort) (global) is 0xFEF8 (-8)
0008   0000             ;       The address of 'timeascii' (long) (global) is 0xFEEE (-18)
0009   0000             ;       The address of 'timebin' (long) (global) is 0xFEEA (-22)
0010   0000             ;       The address of 'sec' (ushort) (global) is 0xFEFB (-5)
0011   0000             ;       The address of 'seccheck' (ushort) (global) is 0xFEF7 (-9)
0012   0000             ;       The address of 'min' (ushort) (global) is 0xFEF5 (-11)
0013   0000             ;       The address of 'hr' (integer) (global) is 0xFEE8 (-24)
0014   0000             ;       The address of 'addmin' (ushort) (global) is 0xFEFF (-1)
0015   0000             ;       The address of 'addhr' (ushort) (global) is 0xFEFE (-2)
0016   0000             ;       The address of 'hrbutton' (ushort) (global) is 0xFEF4 (-12)
0017   0000             ;       The address of 'minbutton' (ushort) (global) is 0xFEF3 (-13)
0018   0000             ;       The address of 'incounter' (ushort) (global) is 0xFEFD (-3)
0019   0000             ;       The address of 'outcounter' (ushort) (global) is 0xFEFC (-4)
0020   0000             ;       The address of 'checkhexsw' (ushort) (global) is 0xFEF2 (-14)
0021   0000             ;       The address of 'colon_state' (ushort) (global) is 0xFEFA (-6)
0022   0000             	EXX_BC .EQU 0xFF02
0023   0000             	EXX_DE .EQU 0xFF04
0024   0000             	EXX_HL .EQU 0xFF06
0025   0000             	EXX_TEMP .EQU 0xFF08
0026   0000             	EXX_TEMPHL .EQU 0xFF0A
0027   0000             	A_TEMP .EQU 0xFF0C
0028   0000             	REG_R3 .EQU 0xFEE7
0029   0000             	REG_R2 .EQU 0xFEE6
0030   0000             	REG_R1 .EQU 0xFEE5
0031   0000             	REG_R0 .EQU 0xFEE4
0032   0000             	.ORG 0000H
0033   0000 21 00 FF    	LXI H,0FF00H
0034   0003 31 E2 FE    	LXI SP,0FEE2H
0035   0006             ; User code start
0036   0006             ; 1: 'FigTroniX 80C85 RealTime Clock 2024 VER 3
0037   0006             ; 2: 
0038   0006             ; 3: ' Initialize clock
0039   0006             ; 4: Poke $fff8, $00  'iniz clock
0040   0006 AF          	XRA A
0041   0007 32 F8 FF    	STA 0FFF8H
0042   000A             ; 5: Poke $fff9, $00  'iniz clock
0043   000A AF          	XRA A
0044   000B 32 F9 FF    	STA 0FFF9H
0045   000E             ; 6: Poke $fffc, $00  'iniz clock
0046   000E AF          	XRA A
0047   000F 32 FC FF    	STA 0FFFCH
0048   0012             ; 7: Poke $fffd, $00  'iniz clock
0049   0012 AF          	XRA A
0050   0013 32 FD FF    	STA 0FFFDH
0051   0016             ; 8: Poke $fffe, $00  'iniz clock
0052   0016 AF          	XRA A
0053   0017 32 FE FF    	STA 0FFFEH
0054   001A             ; 9: 
0055   001A             ; 10: ' Initialize 8155 ports and display colons
0056   001A             ; 11: Put $40, $42  'iniz 8155 PORT A = INPUT, PORT B = OUTPUT, PORT C = INPUT
0057   001A 3E 42       	MVI A,42H
0058   001C D3 40       	OUT 40H
0059   001E             ; 12: Put $42, $00  'clear led 8155
0060   001E AF          	XRA A
0061   001F D3 42       	OUT 42H
0062   0021             ; 13: Put $81, $3a  'place : for clock
0063   0021 3E 3A       	MVI A,3AH
0064   0023 D3 81       	OUT 81H
0065   0025             ; 14: Put $c2, $3a  'place : for clock
0066   0025 3E 3A       	MVI A,3AH
0067   0027 D3 C2       	OUT 0C2H
0068   0029             ; 15: 
0069   0029             ; 16: ' Variable declarations
0070   0029             ; 17: Dim read As Byte
0071   0029             ; 18: Dim write As Byte
0072   0029             ; 19: Dim startclkupdate As Byte
0073   0029             ; 20: Dim timeascii As Long
0074   0029             ; 21: Dim timebin As Long
0075   0029             ; 22: Dim sec As Byte
0076   0029             ; 23: Dim seccheck As Byte
0077   0029             ; 24: Dim min As Byte
0078   0029             ; 25: Dim hr As Integer
0079   0029             ; 26: Dim addmin As Byte
0080   0029             ; 27: Dim addhr As Byte
0081   0029             ; 28: Dim hrbutton As Byte
0082   0029             ; 29: Dim minbutton As Byte
0083   0029             ; 30: Dim incounter As Byte
0084   0029             ; 31: Dim outcounter As Byte
0085   0029             ; 32: Dim checkhexsw As Byte
0086   0029             ; 33: Dim colon_state As Byte  ' Added colon_state variable
0087   0029             ; 34: 
0088   0029             ; 35: ' Initialize variables
0089   0029             ; 36: timeascii = $c000  'SET SAVE POINT FOR TIME IN ASCII
0090   0029 01 00 00    	LXI B,0000H
0091   002C 11 00 C0    	LXI D,0C000H
0092   002F EB          	XCHG
0093   0030 22 EE FE    	SHLD 0FEEEH
0094   0033 60          	MOV H,B
0095   0034 69          	MOV L,C
0096   0035 22 F0 FE    	SHLD 0FEF0H
0097   0038             ; 37: timebin = $b000    'SET SAVE POINT FOR TIME IN BIN
0098   0038 01 00 00    	LXI B,0000H
0099   003B 11 00 B0    	LXI D,0B000H
0100   003E EB          	XCHG
0101   003F 22 EA FE    	SHLD 0FEEAH
0102   0042 60          	MOV H,B
0103   0043 69          	MOV L,C
0104   0044 22 EC FE    	SHLD 0FEECH
0105   0047             ; 38: read = $40         'NEEDED FOR THE UPDATE OF THE RAM LOCATIONS TO ALLOW THE USER TO READ THE TIME
0106   0047 3E 40       	MVI A,40H
0107   0049 32 F6 FE    	STA 0FEF6H
0108   004C             ; 39: write = $80        'NEEDED FOR THE UPDATE OF THE RAM LOCATIONS TO ALLOW THE USER TO WRITE THE TIME
0109   004C 3E 80       	MVI A,80H
0110   004E 32 F9 FE    	STA 0FEF9H
0111   0051             ; 40: startclkupdate = $00  'NEEDED TO START THE CLOCK ON THE REALTIME CLOCK
0112   0051 AF          	XRA A
0113   0052 32 F8 FE    	STA 0FEF8H
0114   0055             ; 41: colon_state = 1       ' Initialize colon_state to 1 (colons displayed)
0115   0055 3E 01       	MVI A,01H
0116   0057 32 FA FE    	STA 0FEFAH
0117   005A             ; 42: 
0118   005A             ; 43: ' Main clock loop
0119   005A             ; 44: clockmain:
0120   005A             L0001:	
0121   005A             ; 45: Poke $fff8, read  'STOP RAM UPDATE TO PREVENT READING THE TIME WHILE THE CLOCK IS UPDATING THE RAM LOCATIONS.
0122   005A 3A F6 FE    	LDA 0FEF6H
0123   005D 32 F8 FF    	STA 0FFF8H
0124   0060             ; 46: sec = Peek($fff9)  'SAVE SEC Data AS INTEGER
0125   0060 3A F9 FF    	LDA 0FFF9H
0126   0063 32 FB FE    	STA 0FEFBH
0127   0066             ; 47: seccheck = sec     'Save SEC to loop until a new sec is detected
0128   0066 3A FB FE    	LDA 0FEFBH
0129   0069 32 F7 FE    	STA 0FEF7H
0130   006C             ; 48: min = Peek($fffa)  'SAVE MIN Data AS INTEGER
0131   006C 3A FA FF    	LDA 0FFFAH
0132   006F 32 F5 FE    	STA 0FEF5H
0133   0072             ; 49: hr = Peek($fffb)   'SAVE HR Data AS INTEGER
0134   0072 3A FB FF    	LDA 0FFFBH
0135   0075 5F          	MOV E,A
0136   0076 16 00       	MVI D,00H
0137   0078 EB          	XCHG
0138   0079 22 E8 FE    	SHLD 0FEE8H
0139   007C             ; 50: 
0140   007C             ; 51: ' Toggle the colon state
0141   007C             ; 52: colon_state = 1 - colon_state  ' Switch between 1 and 0
0142   007C 3E 01       	MVI A,01H
0143   007E 21 FA FE    	LXI H,0FEFAH
0144   0081 6E          	MOV L,M
0145   0082 95          	SUB L
0146   0083 32 FA FE    	STA 0FEFAH
0147   0086             ; 53: 
0148   0086             ; 54: ' Display or clear the colons based on colon_state
0149   0086             ; 55: If colon_state = 1 Then
0150   0086 3A FA FE    	LDA 0FEFAH
0151   0089 2E 01       	MVI L,01H
0152   008B BD          	CMP L
0153   008C C2 9A 00    	JNZ L0010
0154   008F             ; 56: Put $81, $3a  'place : for clock
0155   008F 3E 3A       	MVI A,3AH
0156   0091 D3 81       	OUT 81H
0157   0093             ; 57: Put $c2, $3a  'place : for clock
0158   0093 3E 3A       	MVI A,3AH
0159   0095 D3 C2       	OUT 0C2H
0160   0097             ; 58: Else
0161   0097 C3 A2 00    	JMP L0011
0162   009A             L0010:	
0163   009A             ; 59: Put $81, $3a  'clear : for clock $20 (space character)
0164   009A 3E 3A       	MVI A,3AH
0165   009C D3 81       	OUT 81H
0166   009E             ; 60: Put $c2, $3a  'clear : for clock $20 (space character)
0167   009E 3E 3A       	MVI A,3AH
0168   00A0 D3 C2       	OUT 0C2H
0169   00A2             ; 61: Endif
0170   00A2             L0011:	
0171   00A2             ; 62: 
0172   00A2             ; 63: '*******************************************LED BINARY SEC OUTPUT*******************************************
0173   00A2             ; 64: ASM:        LXI H,sec      'POINT TO MEMORY LOCATION THAT HOLDS THE BCD FOR SEC
0174   00A2 21 FB FE    	LXI H,0FEFBh
0175   00A5             ; 65: ASM:        LXI B,timebin  'POINT TO MEMORY LOCATION THAT WILL HOLD THE TIME IN BINARY
0176   00A5 01 EA FE    	LXI B,0FEEAh
0177   00A8             ; 66: ASM:        MOV A,M        'GET BCD
0178   00A8 7E          	MOV A,M
0179   00A9             ; 67: ASM:        CALL BCDBIN    'CALL BINARY-CODED-DECIMAL TO BINARY CONVERSION
0180   00A9 CD C3 02    	CALL L0004
0181   00AC             ; 68: ASM:        STAX B         'SAVE BINARY
0182   00AC 02          	STAX B
0183   00AD             ; 69: ASM:        LXI H,timebin  'POINT TO MEMORY LOCATION THAT WILL HOLD THE TIME IN BINARY AGAIN
0184   00AD 21 EA FE    	LXI H,0FEEAh
0185   00B0             ; 70: ASM:        MOV A,M        'GET BIN
0186   00B0 7E          	MOV A,M
0187   00B1             ; 71: 'ASM:        CMA           'INVERT THE ACCUMULATOR (commented out as per original code)
0188   00B1             ; 72: ASM:        OUT 42H        'SEND BIN SEC OUT TO LED
0189   00B1 D3 42       	OUT 42H
0190   00B3             ; 73: 
0191   00B3             ; 74: '********************************CHECK SWITCH TO CHANGE BETWEEN DEC OR HEX OUT***************************
0192   00B3             ; 75: checkswitch:
0193   00B3             L0002:	
0194   00B3             ; 76: checkhexsw = Get($41)  '8155 Port A
0195   00B3 DB 41       	IN 41H
0196   00B5 32 F2 FE    	STA 0FEF2H
0197   00B8             ; 77: 
0198   00B8             ; 78: If checkhexsw > $00 Then  'OUTPUT IN DEC
0199   00B8 3A F2 FE    	LDA 0FEF2H
0200   00BB 2E 00       	MVI L,00H
0201   00BD 37          	STC
0202   00BE 9D          	SBB L
0203   00BF DA FB 00    	JC L0012
0204   00C2             ; 79: ' Display seconds
0205   00C2             ; 80: ASM:        LXI H,sec     'POINT TO MEMORY LOCATION THAT HOLDS THE CURRENT SEC
0206   00C2 21 FB FE    	LXI H,0FEFBh
0207   00C5             ; 81: ASM:        CALL BINASCII 'CALL BINARY TO ASCII CONVERSION
0208   00C5 CD DF 02    	CALL L0007
0209   00C8             ; 82: ASM:        LXI H,timeascii  'POINT TO MEMORY LOCATION THAT HOLDS THE TIME IN ASCII
0210   00C8 21 EE FE    	LXI H,0FEEEh
0211   00CB             ; 83: ASM:        MOV A,M       'GET ASCII
0212   00CB 7E          	MOV A,M
0213   00CC             ; 84: ASM:        OUT 00C1H     'SEND TO DISPLAY
0214   00CC D3 C1       	OUT 00C1H
0215   00CE             ; 85: ASM:        INX H         'POINT TO NEXT ASCII CHAR
0216   00CE 23          	INX H
0217   00CF             ; 86: ASM:        MOV A,M       'GET ASCII
0218   00CF 7E          	MOV A,M
0219   00D0             ; 87: ASM:        OUT 00C0H     'SEND TO DISPLAY
0220   00D0 D3 C0       	OUT 00C0H
0221   00D2             ; 88: 
0222   00D2             ; 89: ' Display minutes
0223   00D2             ; 90: ASM:        LXI H,min     'POINT TO MEMORY LOCATION THAT HOLDS THE CURRENT MIN
0224   00D2 21 F5 FE    	LXI H,0FEF5h
0225   00D5             ; 91: ASM:        CALL BINASCII 'CALL BINARY TO ASCII CONVERSION
0226   00D5 CD DF 02    	CALL L0007
0227   00D8             ; 92: ASM:        LXI H,timeascii  'POINT TO MEMORY LOCATION THAT HOLDS THE TIME IN ASCII
0228   00D8 21 EE FE    	LXI H,0FEEEh
0229   00DB             ; 93: ASM:        MOV A,M       'GET ASCII
0230   00DB 7E          	MOV A,M
0231   00DC             ; 94: ASM:        OUT 0080H     'SEND TO DISPLAY
0232   00DC D3 80       	OUT 0080H
0233   00DE             ; 95: ASM:        INX H         'POINT TO NEXT ASCII CHAR
0234   00DE 23          	INX H
0235   00DF             ; 96: ASM:        MOV A,M       'GET ASCII
0236   00DF 7E          	MOV A,M
0237   00E0             ; 97: ASM:        OUT 00C3H     'SEND TO DISPLAY
0238   00E0 D3 C3       	OUT 00C3H
0239   00E2             ; 98: 
0240   00E2             ; 99: ' Display hours
0241   00E2             ; 100: ASM:        LXI H,hr      'POINT TO MEMORY LOCATION THAT HOLDS THE CURRENT HR
0242   00E2 21 E8 FE    	LXI H,0FEE8h
0243   00E5             ; 101: ASM:        CALL BINASCII 'CALL BINARY TO ASCII CONVERSION
0244   00E5 CD DF 02    	CALL L0007
0245   00E8             ; 102: ASM:        LXI H,timeascii  'POINT TO MEMORY LOCATION THAT HOLDS THE TIME IN ASCII
0246   00E8 21 EE FE    	LXI H,0FEEEh
0247   00EB             ; 103: ASM:        MOV A,M       'GET ASCII
0248   00EB 7E          	MOV A,M
0249   00EC             ; 104: ASM:        OUT 0083H     'SEND TO DISPLAY
0250   00EC D3 83       	OUT 0083H
0251   00EE             ; 105: ASM:        INX H         'POINT TO NEXT ASCII CHAR
0252   00EE 23          	INX H
0253   00EF             ; 106: ASM:        MOV A,M       'GET ASCII
0254   00EF 7E          	MOV A,M
0255   00F0             ; 107: ASM:        OUT 0082H     'SEND TO DISPLAY
0256   00F0 D3 82       	OUT 0082H
0257   00F2             ; 108: 
0258   00F2             ; 109: Poke $fff8, startclkupdate  'START THE RAM CLOCK UPDATE
0259   00F2 3A F8 FE    	LDA 0FEF8H
0260   00F5 32 F8 FF    	STA 0FFF8H
0261   00F8             ; 110: Else  'OUTPUT IN HEX
0262   00F8 C3 52 01    	JMP L0013
0263   00FB             L0012:	
0264   00FB             ; 111: ' Display seconds in HEX
0265   00FB             ; 112: ASM:        LXI H,sec     'POINT TO MEMORY LOCATION THAT HOLDS THE BCD FOR SEC
0266   00FB 21 FB FE    	LXI H,0FEFBh
0267   00FE             ; 113: ASM:        LXI B,timebin 'POINT TO MEMORY LOCATION THAT WILL HOLD THE TIME IN BINARY
0268   00FE 01 EA FE    	LXI B,0FEEAh
0269   0101             ; 114: ASM:        MOV A,M       'GET BCD
0270   0101 7E          	MOV A,M
0271   0102             ; 115: ASM:        CALL BCDBIN   'CONVERT BCD TO BINARY
0272   0102 CD C3 02    	CALL L0004
0273   0105             ; 116: ASM:        STAX B        'SAVE BINARY
0274   0105 02          	STAX B
0275   0106             ; 117: ASM:        LXI H,timebin 'POINT TO BINARY TIME
0276   0106 21 EA FE    	LXI H,0FEEAh
0277   0109             ; 118: ASM:        CALL BINASCII 'CONVERT BINARY TO ASCII
0278   0109 CD DF 02    	CALL L0007
0279   010C             ; 119: ASM:        LXI H,timeascii  'POINT TO ASCII TIME
0280   010C 21 EE FE    	LXI H,0FEEEh
0281   010F             ; 120: ASM:        MOV A,M       'GET ASCII
0282   010F 7E          	MOV A,M
0283   0110             ; 121: ASM:        OUT 00C1H     'SEND TO DISPLAY
0284   0110 D3 C1       	OUT 00C1H
0285   0112             ; 122: ASM:        INX H         'POINT TO NEXT ASCII CHAR
0286   0112 23          	INX H
0287   0113             ; 123: ASM:        MOV A,M       'GET ASCII
0288   0113 7E          	MOV A,M
0289   0114             ; 124: ASM:        OUT 00C0H     'SEND TO DISPLAY
0290   0114 D3 C0       	OUT 00C0H
0291   0116             ; 125: 
0292   0116             ; 126: ' Display minutes in HEX
0293   0116             ; 127: ASM:        LXI H,min     'POINT TO MEMORY LOCATION THAT HOLDS THE BCD FOR MIN
0294   0116 21 F5 FE    	LXI H,0FEF5h
0295   0119             ; 128: ASM:        LXI B,timebin 'POINT TO BINARY TIME STORAGE
0296   0119 01 EA FE    	LXI B,0FEEAh
0297   011C             ; 129: ASM:        MOV A,M       'GET BCD
0298   011C 7E          	MOV A,M
0299   011D             ; 130: ASM:        CALL BCDBIN   'CONVERT BCD TO BINARY
0300   011D CD C3 02    	CALL L0004
0301   0120             ; 131: ASM:        STAX B        'SAVE BINARY
0302   0120 02          	STAX B
0303   0121             ; 132: ASM:        LXI H,timebin 'POINT TO BINARY TIME
0304   0121 21 EA FE    	LXI H,0FEEAh
0305   0124             ; 133: ASM:        CALL BINASCII 'CONVERT BINARY TO ASCII
0306   0124 CD DF 02    	CALL L0007
0307   0127             ; 134: ASM:        LXI H,timeascii  'POINT TO ASCII TIME
0308   0127 21 EE FE    	LXI H,0FEEEh
0309   012A             ; 135: ASM:        MOV A,M       'GET ASCII
0310   012A 7E          	MOV A,M
0311   012B             ; 136: ASM:        OUT 0080H     'SEND TO DISPLAY
0312   012B D3 80       	OUT 0080H
0313   012D             ; 137: ASM:        INX H         'POINT TO NEXT ASCII CHAR
0314   012D 23          	INX H
0315   012E             ; 138: ASM:        MOV A,M       'GET ASCII
0316   012E 7E          	MOV A,M
0317   012F             ; 139: ASM:        OUT 00C3H     'SEND TO DISPLAY
0318   012F D3 C3       	OUT 00C3H
0319   0131             ; 140: 
0320   0131             ; 141: ' Display hours in HEX
0321   0131             ; 142: ASM:        LXI H,hr      'POINT TO MEMORY LOCATION THAT HOLDS THE BCD FOR HR
0322   0131 21 E8 FE    	LXI H,0FEE8h
0323   0134             ; 143: ASM:        LXI B,timebin 'POINT TO BINARY TIME STORAGE
0324   0134 01 EA FE    	LXI B,0FEEAh
0325   0137             ; 144: ASM:        MOV A,M       'GET BCD
0326   0137 7E          	MOV A,M
0327   0138             ; 145: ASM:        CALL BCDBIN   'CONVERT BCD TO BINARY
0328   0138 CD C3 02    	CALL L0004
0329   013B             ; 146: ASM:        STAX B        'SAVE BINARY
0330   013B 02          	STAX B
0331   013C             ; 147: ASM:        LXI H,timebin 'POINT TO BINARY TIME
0332   013C 21 EA FE    	LXI H,0FEEAh
0333   013F             ; 148: ASM:        CALL BINASCII 'CONVERT BINARY TO ASCII
0334   013F CD DF 02    	CALL L0007
0335   0142             ; 149: ASM:        LXI H,timeascii  'POINT TO ASCII TIME
0336   0142 21 EE FE    	LXI H,0FEEEh
0337   0145             ; 150: ASM:        MOV A,M       'GET ASCII
0338   0145 7E          	MOV A,M
0339   0146             ; 151: ASM:        OUT 0083H     'SEND TO DISPLAY
0340   0146 D3 83       	OUT 0083H
0341   0148             ; 152: ASM:        INX H         'POINT TO NEXT ASCII CHAR
0342   0148 23          	INX H
0343   0149             ; 153: ASM:        MOV A,M       'GET ASCII
0344   0149 7E          	MOV A,M
0345   014A             ; 154: ASM:        OUT 0082H     'SEND TO DISPLAY
0346   014A D3 82       	OUT 0082H
0347   014C             ; 155: 
0348   014C             ; 156: Poke $fff8, startclkupdate  'START THE RAM CLOCK UPDATE
0349   014C 3A F8 FE    	LDA 0FEF8H
0350   014F 32 F8 FF    	STA 0FFF8H
0351   0152             ; 157: Endif
0352   0152             L0013:	
0353   0152             ; 158: 
0354   0152             ; 159: 'CHECK HR BUTTON LOGIC
0355   0152             ; 160: hrbutton = Get($43)  'SET VAR TO BUTTON INPUT FROM 8155 PC0
0356   0152 DB 43       	IN 43H
0357   0154 32 F4 FE    	STA 0FEF4H
0358   0157             ; 161: If hrbutton = $08 Then  'LOGIC, DETECT BUTTON PRESS
0359   0157 3A F4 FE    	LDA 0FEF4H
0360   015A 2E 08       	MVI L,08H
0361   015C BD          	CMP L
0362   015D C2 F7 01    	JNZ L0014
0363   0160             ; 162: Poke $fff8, write   'STOP RAM UPDATE TO PREVENT WRITING THE TIME WHILE THE CLOCK IS UPDATING THE RAM LOCATIONS.
0364   0160 3A F9 FE    	LDA 0FEF9H
0365   0163 32 F8 FF    	STA 0FFF8H
0366   0166             ; 163: addhr = Peek($fffb) 'GET HR
0367   0166 3A FB FF    	LDA 0FFFBH
0368   0169 32 FE FE    	STA 0FEFEH
0369   016C             ; 164: addhr = addhr + 1   'INCREASE HR BY ONE
0370   016C 3A FE FE    	LDA 0FEFEH
0371   016F 2E 01       	MVI L,01H
0372   0171 85          	ADD L
0373   0172 32 FE FE    	STA 0FEFEH
0374   0175             ; 165: ' Adjust for BCD overflow
0375   0175             ; 166: If (addhr And $0f) > $09 Then addhr = addhr + $06
0376   0175             	oshonsoft_temp_ushort_1 .EQU 0xFEE3
0377   0175 0E 0F       	MVI C,0FH
0378   0177 3A FE FE    	LDA 0FEFEH
0379   017A A1          	ANA C
0380   017B 32 E3 FE    	STA 0FEE3H
0381   017E             	oshonsoft_temp_boolean_2 .EQU 0xFEE2
0382   017E AF          	XRA A
0383   017F 32 E2 FE    	STA 0FEE2H
0384   0182 3A E3 FE    	LDA 0FEE3H
0385   0185 2E 09       	MVI L,09H
0386   0187 37          	STC
0387   0188 9D          	SBB L
0388   0189 DA 91 01    	JC L0016
0389   018C 3E FF       	MVI A,0FFH
0390   018E 32 E2 FE    	STA 0FEE2H
0391   0191             L0016:	
0392   0191 3A E2 FE    	LDA 0FEE2H
0393   0194 2E FF       	MVI L,0FFH
0394   0196 95          	SUB L
0395   0197 C2 A3 01    	JNZ L0015
0396   019A 3A FE FE    	LDA 0FEFEH
0397   019D 2E 06       	MVI L,06H
0398   019F 85          	ADD L
0399   01A0 32 FE FE    	STA 0FEFEH
0400   01A3             L0015:	
0401   01A3             ; 167: If addhr > $23 Then addhr = $00  ' Reset hour if overflow
0402   01A3 3A FE FE    	LDA 0FEFEH
0403   01A6 2E 23       	MVI L,23H
0404   01A8 37          	STC
0405   01A9 9D          	SBB L
0406   01AA DA B1 01    	JC L0017
0407   01AD AF          	XRA A
0408   01AE 32 FE FE    	STA 0FEFEH
0409   01B1             L0017:	
0410   01B1             ; 168: Poke $fffb, addhr    'PLACE NEW HR TO RAM LOCATION
0411   01B1 3A FE FE    	LDA 0FEFEH
0412   01B4 32 FB FF    	STA 0FFFBH
0413   01B7             ; 169: Poke $fff8, startclkupdate  'RESTART THE CLOCK
0414   01B7 3A F8 FE    	LDA 0FEF8H
0415   01BA 32 F8 FF    	STA 0FFF8H
0416   01BD             ; 170: 'WAIT FOR BOUNCE PREVENTION
0417   01BD             ; 171: For outcounter = 0 To 10
0418   01BD AF          	XRA A
0419   01BE 32 FC FE    	STA 0FEFCH
0420   01C1             L0018:	
0421   01C1 3A FC FE    	LDA 0FEFCH
0422   01C4 2E 0A       	MVI L,0AH
0423   01C6 37          	STC
0424   01C7 9D          	SBB L
0425   01C8 D2 F7 01    	JNC L0019
0426   01CB             ; 172: For incounter = 0 To 10
0427   01CB AF          	XRA A
0428   01CC 32 FD FE    	STA 0FEFDH
0429   01CF             L0020:	
0430   01CF 3A FD FE    	LDA 0FEFDH
0431   01D2 2E 0A       	MVI L,0AH
0432   01D4 37          	STC
0433   01D5 9D          	SBB L
0434   01D6 D2 E8 01    	JNC L0021
0435   01D9             ; 173: Next incounter
0436   01D9 3A FD FE    	LDA 0FEFDH
0437   01DC 2E 01       	MVI L,01H
0438   01DE 85          	ADD L
0439   01DF 32 FD FE    	STA 0FEFDH
0440   01E2 DA E8 01    	JC L0021
0441   01E5 C3 CF 01    	JMP L0020
0442   01E8             L0021:	
0443   01E8             ; 174: Next outcounter
0444   01E8 3A FC FE    	LDA 0FEFCH
0445   01EB 2E 01       	MVI L,01H
0446   01ED 85          	ADD L
0447   01EE 32 FC FE    	STA 0FEFCH
0448   01F1 DA F7 01    	JC L0019
0449   01F4 C3 C1 01    	JMP L0018
0450   01F7             L0019:	
0451   01F7             ; 175: Endif
0452   01F7             L0014:	
0453   01F7             ; 176: 
0454   01F7             ; 177: 'CHECK MIN BUTTON LOGIC
0455   01F7             ; 178: minbutton = Get($43)  'SET VAR TO BUTTON INPUT FROM 8155 PC1
0456   01F7 DB 43       	IN 43H
0457   01F9 32 F3 FE    	STA 0FEF3H
0458   01FC             ; 179: If minbutton = $04 Then  'LOGIC, DETECT BUTTON PRESS
0459   01FC 3A F3 FE    	LDA 0FEF3H
0460   01FF 2E 04       	MVI L,04H
0461   0201 BD          	CMP L
0462   0202 C2 A0 02    	JNZ L0022
0463   0205             ; 180: Poke $fff8, write   'STOP RAM UPDATE TO PREVENT WRITING THE TIME WHILE THE CLOCK IS UPDATING THE RAM LOCATIONS.
0464   0205 3A F9 FE    	LDA 0FEF9H
0465   0208 32 F8 FF    	STA 0FFF8H
0466   020B             ; 181: Poke $fff9, $00     'WRITE 00 TO THE SEC LOCATION.
0467   020B AF          	XRA A
0468   020C 32 F9 FF    	STA 0FFF9H
0469   020F             ; 182: addmin = Peek($fffa) 'GET MIN
0470   020F 3A FA FF    	LDA 0FFFAH
0471   0212 32 FF FE    	STA 0FEFFH
0472   0215             ; 183: addmin = addmin + 1  'INCREASE MIN BY ONE
0473   0215 3A FF FE    	LDA 0FEFFH
0474   0218 2E 01       	MVI L,01H
0475   021A 85          	ADD L
0476   021B 32 FF FE    	STA 0FEFFH
0477   021E             ; 184: ' Adjust for BCD overflow
0478   021E             ; 185: If (addmin And $0f) > $09 Then addmin = addmin + $06
0479   021E 0E 0F       	MVI C,0FH
0480   0220 3A FF FE    	LDA 0FEFFH
0481   0223 A1          	ANA C
0482   0224 32 E3 FE    	STA 0FEE3H
0483   0227 AF          	XRA A
0484   0228 32 E2 FE    	STA 0FEE2H
0485   022B 3A E3 FE    	LDA 0FEE3H
0486   022E 2E 09       	MVI L,09H
0487   0230 37          	STC
0488   0231 9D          	SBB L
0489   0232 DA 3A 02    	JC L0024
0490   0235 3E FF       	MVI A,0FFH
0491   0237 32 E2 FE    	STA 0FEE2H
0492   023A             L0024:	
0493   023A 3A E2 FE    	LDA 0FEE2H
0494   023D 2E FF       	MVI L,0FFH
0495   023F 95          	SUB L
0496   0240 C2 4C 02    	JNZ L0023
0497   0243 3A FF FE    	LDA 0FEFFH
0498   0246 2E 06       	MVI L,06H
0499   0248 85          	ADD L
0500   0249 32 FF FE    	STA 0FEFFH
0501   024C             L0023:	
0502   024C             ; 186: If addmin > $59 Then addmin = $00  ' Reset minute if overflow
0503   024C 3A FF FE    	LDA 0FEFFH
0504   024F 2E 59       	MVI L,59H
0505   0251 37          	STC
0506   0252 9D          	SBB L
0507   0253 DA 5A 02    	JC L0025
0508   0256 AF          	XRA A
0509   0257 32 FF FE    	STA 0FEFFH
0510   025A             L0025:	
0511   025A             ; 187: Poke $fffa, addmin   'PLACE NEW MIN TO RAM LOCATION
0512   025A 3A FF FE    	LDA 0FEFFH
0513   025D 32 FA FF    	STA 0FFFAH
0514   0260             ; 188: Poke $fff8, startclkupdate  'RESTART THE CLOCK
0515   0260 3A F8 FE    	LDA 0FEF8H
0516   0263 32 F8 FF    	STA 0FFF8H
0517   0266             ; 189: 'WAIT FOR BOUNCE PREVENTION
0518   0266             ; 190: For outcounter = 0 To 10
0519   0266 AF          	XRA A
0520   0267 32 FC FE    	STA 0FEFCH
0521   026A             L0026:	
0522   026A 3A FC FE    	LDA 0FEFCH
0523   026D 2E 0A       	MVI L,0AH
0524   026F 37          	STC
0525   0270 9D          	SBB L
0526   0271 D2 A0 02    	JNC L0027
0527   0274             ; 191: For incounter = 0 To 10
0528   0274 AF          	XRA A
0529   0275 32 FD FE    	STA 0FEFDH
0530   0278             L0028:	
0531   0278 3A FD FE    	LDA 0FEFDH
0532   027B 2E 0A       	MVI L,0AH
0533   027D 37          	STC
0534   027E 9D          	SBB L
0535   027F D2 91 02    	JNC L0029
0536   0282             ; 192: Next incounter
0537   0282 3A FD FE    	LDA 0FEFDH
0538   0285 2E 01       	MVI L,01H
0539   0287 85          	ADD L
0540   0288 32 FD FE    	STA 0FEFDH
0541   028B DA 91 02    	JC L0029
0542   028E C3 78 02    	JMP L0028
0543   0291             L0029:	
0544   0291             ; 193: Next outcounter
0545   0291 3A FC FE    	LDA 0FEFCH
0546   0294 2E 01       	MVI L,01H
0547   0296 85          	ADD L
0548   0297 32 FC FE    	STA 0FEFCH
0549   029A DA A0 02    	JC L0027
0550   029D C3 6A 02    	JMP L0026
0551   02A0             L0027:	
0552   02A0             ; 194: Endif
0553   02A0             L0022:	
0554   02A0             ; 195: 
0555   02A0             ; 196: 'RESTART THE CLOCK UPDATE
0556   02A0             ; 197: Poke $fff8, startclkupdate  'START THE RAM CLOCK UPDATE
0557   02A0 3A F8 FE    	LDA 0FEF8H
0558   02A3 32 F8 FF    	STA 0FFF8H
0559   02A6             ; 198: 
0560   02A6             ; 199: ' Go to secondcheck to wait for the next second
0561   02A6             ; 200: Goto secondcheck
0562   02A6 C3 A9 02    	JMP L0003
0563   02A9             ; 201: 
0564   02A9             ; 202: secondcheck:
0565   02A9             L0003:	
0566   02A9             ; 203: sec = Peek($fff9)  'SAVE SEC LOCATION AS INTEGER
0567   02A9 3A F9 FF    	LDA 0FFF9H
0568   02AC 32 FB FE    	STA 0FEFBH
0569   02AF             ; 204: If sec = seccheck Then
0570   02AF 3A FB FE    	LDA 0FEFBH
0571   02B2 21 F7 FE    	LXI H,0FEF7H
0572   02B5 6E          	MOV L,M
0573   02B6 BD          	CMP L
0574   02B7 C2 C0 02    	JNZ L0030
0575   02BA             ; 205: Goto secondcheck
0576   02BA C3 A9 02    	JMP L0003
0577   02BD             ; 206: Else
0578   02BD C3 C3 02    	JMP L0031
0579   02C0             L0030:	
0580   02C0             ; 207: Goto clockmain
0581   02C0 C3 5A 00    	JMP L0001
0582   02C3             ; 208: Endif
0583   02C3             L0031:	
0584   02C3             ; 209: 
0585   02C3             ; 210: '*****************************************************GLOBAL FUNCTIONS*****************************************************
0586   02C3             ; 211: ASM:BCDBIN:
0587   02C3             L0004:	
0588   02C3             ; 212: ASM:        PUSH B      'SAVE BC REG
0589   02C3 C5          	PUSH B
0590   02C4             ; 213: ASM:        PUSH D      'SAVE DE REG
0591   02C4 D5          	PUSH D
0592   02C5             ; 214: ASM:        MOV B,A     'SAVE BCD
0593   02C5 47          	MOV B,A
0594   02C6             ; 215: ASM:        ANI 0FH     'MASK LEAST SIGNIFICANT FOUR BITS
0595   02C6 E6 0F       	ANI 0FH
0596   02C8             ; 216: ASM:        MOV C,A     'SAVE UNPACKED BCD IN C REG
0597   02C8 4F          	MOV C,A
0598   02C9             ; 217: ASM:        MOV A,B     'GET BCD AGAIN
0599   02C9 78          	MOV A,B
0600   02CA             ; 218: ASM:        ANI F0H     'MASK MOST SIGNIFICANT FOUR BITS
0601   02CA E6 F0       	ANI F0H
0602   02CC             ; 219: ASM:        RRC         'SHIFT FOUR TIMES TO GET UPPER NIBBLE
0603   02CC 0F          	RRC
0604   02CD             ; 220: ASM:        RRC
0605   02CD 0F          	RRC
0606   02CE             ; 221: ASM:        RRC
0607   02CE 0F          	RRC
0608   02CF             ; 222: ASM:        RRC
0609   02CF 0F          	RRC
0610   02D0             ; 223: ASM:        MOV D,A     'SAVE UPPER NIBBLE
0611   02D0 57          	MOV D,A
0612   02D1             ; 224: ASM:        MVI E,10    'SET E AS MULTIPLIER OF 10
0613   02D1 1E 0A       	MVI E,10
0614   02D3             ; 225: ASM:SUM:
0615   02D3             L0005:	
0616   02D3             ; 226: ASM:        DCR D       'DECREMENT D
0617   02D3 15          	DCR D
0618   02D4             ; 227: ASM:        JZ SUM_END  'IF D=0, EXIT LOOP
0619   02D4 CA DB 02    	JZ L0006
0620   02D7             ; 228: ASM:        ADD E       'ADD 10 TO A
0621   02D7 83          	ADD E
0622   02D8             ; 229: ASM:        JMP SUM     'REPEAT LOOP
0623   02D8 C3 D3 02    	JMP L0005
0624   02DB             ; 230: ASM:SUM_END:
0625   02DB             L0006:	
0626   02DB             ; 231: ASM:        ADD C       'ADD LOWER NIBBLE
0627   02DB 81          	ADD C
0628   02DC             ; 232: ASM:        POP D       'RETRIEVE PREVIOUS CONTENTS
0629   02DC D1          	POP D
0630   02DD             ; 233: ASM:        POP B
0631   02DD C1          	POP B
0632   02DE             ; 234: ASM:        RET         'RETURN
0633   02DE C9          	RET
0634   02DF             ; 235: 
0635   02DF             ; 236: ASM:BINASCII:
0636   02DF             L0007:	
0637   02DF             ; 237: ASM:        LXI D,timeascii  'POINT INDEX TO WHERE ASCII CODE IS TO BE STORED
0638   02DF 11 EE FE    	LXI D,0FEEEh
0639   02E2             ; 238: ASM:        MOV A,M          'GET BYTE
0640   02E2 7E          	MOV A,M
0641   02E3             ; 239: ASM:        MOV B,A          'SAVE BYTE
0642   02E3 47          	MOV B,A
0643   02E4             ; 240: ASM:        RRC              'ROTATE FOUR TIMES TO PLACE THE FOUR HIGH ORDER BITS OF THE SELECTED BYTE IN THE LOW ORDER LOCATION
0644   02E4 0F          	RRC
0645   02E5             ; 241: ASM:        RRC
0646   02E5 0F          	RRC
0647   02E6             ; 242: ASM:        RRC
0648   02E6 0F          	RRC
0649   02E7             ; 243: ASM:        RRC
0650   02E7 0F          	RRC
0651   02E8             ; 244: ASM:        CALL ASCII       'CALL ASCII CONVERSION
0652   02E8 CD F3 02    	CALL L0008
0653   02EB             ; 245: ASM:        STAX D           'SAVE FIRST ASCII HEX
0654   02EB 12          	STAX D
0655   02EC             ; 246: ASM:        INX D            'POINT TO NEXT MEMORY LOCATION
0656   02EC 13          	INX D
0657   02ED             ; 247: ASM:        MOV A,B          'GET BYTE
0658   02ED 78          	MOV A,B
0659   02EE             ; 248: ASM:        CALL ASCII       'CALL ASCII CONVERSION
0660   02EE CD F3 02    	CALL L0008
0661   02F1             ; 249: ASM:        STAX D           'SAVE NEXT ASCII HEX
0662   02F1 12          	STAX D
0663   02F2             ; 250: ASM:        RET              'RETURN
0664   02F2 C9          	RET
0665   02F3             ; 251: 
0666   02F3             ; 252: ASM:ASCII:
0667   02F3             L0008:	
0668   02F3             ; 253: ASM:        ANI 0FH          'MASK HIGH-ORDER NIBBLE
0669   02F3 E6 0F       	ANI 0FH
0670   02F5             ; 254: ASM:        CPI 0AH          'IS DIGIT LESS THAN 10?
0671   02F5 FE 0A       	CPI 0AH
0672   02F7             ; 255: ASM:        JC CODE          'IF YES GOTO CODE TO ADD 30H
0673   02F7 DA FC 02    	JC L0009
0674   02FA             ; 256: ASM:        ADI 07H          'ELSE ADD 07H TO GET A - F CHAR
0675   02FA C6 07       	ADI 07H
0676   02FC             ; 257: ASM:CODE:
0677   02FC             L0009:	
0678   02FC             ; 258: ASM:        ADI 30H          'ADD 30H AS A DECIMAL OFFSET
0679   02FC C6 30       	ADI 30H
0680   02FE             ; 259: ASM:        RET              'RETURN
0681   02FE C9          	RET
0682   02FF             ; End of user code
0683   02FF 76          	HLT
0684   0300             ; End of listing
0685   0300             	.END
Number of errors = 0
